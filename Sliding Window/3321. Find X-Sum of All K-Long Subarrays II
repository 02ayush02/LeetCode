class Solution {
public:
    #define ll long long
    set<pair<int, int>> main;
    set<pair<int, int>> sec;

    void addElement(const unordered_map<int, int>& mpp, const int num, int x, ll& sum) {
        pair<int,int> p = {mpp.at(num), num};

        if (main.size() <= x || p > *main.begin()) {
            sum += 1LL * p.first * p.second;
            main.insert(p);

            if ((int)main.size() > x) {
                auto smallest = *main.begin();
                sum -= 1LL * smallest.first * smallest.second;
                main.erase(main.begin());
                sec.insert(smallest);
            }
        } else {
            sec.insert(p);
        }
    }

    void removeElement(const unordered_map<int, int>& mpp, const int num, int x, ll& sum) {
        pair<int,int> p = {mpp.at(num), num};

        if (main.find(p) != main.end()) {
            sum -= 1LL * p.first * p.second;
            main.erase(p);

            if (!sec.empty()) {
                auto it = prev(sec.end());
                pair<int,int> a = *it;
                sec.erase(it);
                main.insert(a);
                sum += 1LL * a.first * a.second;
            }
        } else {
            sec.erase(p);
        }
    }

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        unordered_map<int, int> mpp;
        vector<ll> ans;
        ll sum = 0;

        int i = 0;
        for (int j = 0; j < n; j++) {
            if (mpp[nums[j]] > 0) {
                removeElement(mpp, nums[j], x, sum);
            }
            mpp[nums[j]]++;
            addElement(mpp, nums[j], x, sum);

            if (j - i + 1 == k) {
                ans.push_back(sum);
                removeElement(mpp, nums[i], x, sum);
                mpp[nums[i]]--;

                if (mpp[nums[i]] == 0) {
                    mpp.erase(nums[i]);
                } else {
                    addElement(mpp, nums[i], x, sum);
                }
                i++;
            }
        }

        return ans;




    // using ll = long long;
    // struct Comp {
    //     bool operator()(const pair<ll,ll>& a, const pair<ll,ll>& b) const {
    //         if (a.first != b.first) {
    //             return a.first > b.first; 
    //         }  
    //         return a.second > b.second;          
    //     }
    // };

    // ll func(unordered_map<ll,ll>& mpp, ll x) {
    //     priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, Comp> pq;

    //     for (auto &p : mpp) {
    //         pq.push({p.second, p.first});
    //         if ((int)pq.size() > x) pq.pop();
    //     }

    //     ll sum = 0;
    //     while (!pq.empty()) {
    //         auto t = pq.top(); pq.pop();
    //         sum += t.first * t.second;
    //     }
    //     return sum;
    // }

    // vector<long long> findXSum(vector<int>& nums, int k, int x) {
    //     vector<ll> ans;
    //     int n = nums.size();
    //     if (k <= 0 || n == 0) return ans;

    //     unordered_map<ll,ll> mpp;
    //     int i = 0;

    //     for (int j = 0; j < n; ++j) {
    //         mpp[nums[j]]++;

    //         if (j - i + 1 == k) {
    //             ans.push_back(func(mpp, x));
    //             mpp[nums[i]]--;
    //             if (mpp[nums[i]] == 0) mpp.erase(nums[i]);
    //             i++;
    //         }
    //     }
    //     return ans;

    }
};
